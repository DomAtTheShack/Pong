Index: src/GameGUI/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package GameGUI;\r\n\r\nimport java.awt.*;\r\nimport java.awt.image.BufferStrategy;\r\nimport java.io.IOException;\r\nimport java.util.Random;\r\n\r\n\r\npublic class Game extends Canvas implements Runnable {\r\n\r\n    private static boolean isRunning = false;\r\n    private static Thread thread;\r\n    public static Handler MainHandler = new Handler();\r\n    public static byte fps;\r\n    private Handler Paddle1;\r\n    private Handler Paddle2;\r\n    private Random location = new Random();\r\n\r\n    private Random time = new Random();\r\n\r\n    private long randoNum = 0;\r\n\r\n\r\n    public static int frames = 0;\r\n    public static int updates = 0;\r\n\r\n    public Game() throws IOException {\r\n\r\n        new Window(1000, 700, \"Pong\", this);\r\n        start();\r\n        Paddle1 = new Handler();\r\n        Paddle2 = new Handler();\r\n        MainHandler.addHandler(Paddle1);\r\n        MainHandler.addHandler(Paddle2);\r\n        this.addKeyListener(new KeyListener(Paddle2));\r\n        this.addKeyListener(new KeyListener(Paddle1));\r\n        Paddle1.addObject(new Pabble(30, 275, 20, 70, ID.P1Pabble, Paddle1));\r\n        Paddle2.addObject(new Pabble(935, 275, 20, 70, ID.P2Pabble, Paddle2));\r\n        MainHandler.addObject(new Display(475, 10, ID.Display, \"N/A\"));\r\n        MainHandler.addObject(new Display(395, 130, ID.P1Score, \"0\"));\r\n        MainHandler.addObject(new Display(555, 130, ID.P2Score, \"0\"));\r\n        MainHandler.addObject(new Ball(100, 100, 20, 20, ID.Ball));\r\n\r\n\r\n    }\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        new Game();\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        this.requestFocus();\r\n        final int targetFps = 60;\r\n        final long nanoSecondInterval = 1_000_000_000 / targetFps;\r\n        long lastTime = System.nanoTime();\r\n        long timer = System.currentTimeMillis();\r\n\r\n\r\n        while (isRunning) {\r\n            long now = System.nanoTime();\r\n            if (now - lastTime > nanoSecondInterval) {\r\n                tick();\r\n                updates++;\r\n                render();\r\n                frames++;\r\n                lastTime = now;\r\n            }\r\n\r\n            if (System.currentTimeMillis() - timer > 1000) {\r\n                timer += 1000;\r\n                fps = (byte) frames;\r\n                frames = 0;\r\n                updates = 0;\r\n            }\r\n        }\r\n\r\n        try {\r\n            stop();\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    public void render() {\r\n        BufferStrategy bs = this.getBufferStrategy();\r\n        if (bs == null) {\r\n            this.createBufferStrategy(3);\r\n            return;\r\n        }\r\n        Graphics g = bs.getDrawGraphics();\r\n        g.setColor(new Color(136, 202, 252));\r\n        g.fillRect(0, 0, getWidth(), getHeight());\r\n        MainHandler.render(g);\r\n        Paddle2.render(g);\r\n        Paddle1.render(g);\r\n\r\n        g.dispose();\r\n        bs.show();\r\n    }\r\n\r\n    public void tick() {\r\n        randoNum++;\r\n        if (randoNum >= PowerUp()) {\r\n            MainHandler.addObject(new PowerUps(location.nextInt(350) + 320,\r\n                    location.nextInt(400) + 150,\r\n                    20, 20,\r\n                    ID.SpedPU));\r\n            randoNum = 0;\r\n            PowerUp();\r\n        }\r\n        MainHandler.tick();\r\n        Paddle2.tick();\r\n        Paddle1.tick();\r\n    }\r\n\r\n    private void start() {\r\n        isRunning = true;\r\n        thread = new Thread(this);\r\n        thread.start();\r\n    }\r\n\r\n    private void stop() throws InterruptedException\r\n    {\r\n        isRunning = false;\r\n        thread.join();\r\n    }\r\n\r\n\r\n    private int PowerUp()\r\n    {\r\n\r\n        return time.nextInt(60) + 0;\r\n\r\n    }\r\n}\r\n\r\n\r\n/*\r\nThis function is typically found in games or graphics-intensive programs written in Java, and it's used to render (or draw) graphics onto the screen using something called \"double-buffering\" or in this case \"triple buffering\", hence the '3' in createBufferStrategy(3). Buffering is used to prevent screen tearing, an issue where multiple frames are shown in a single screen draw.\r\nHere's what each line of your function does:\r\nBufferStrategy bs = this.getBufferStrategy(); - The getBufferStrategy method retrieves the BufferStrategy that has been created for this component. It's used for buffering graphics that will be drawn onto the screen.\r\nif(bs == null) {...} - This block checks if a BufferStrategy has been created, and if not, it creates one using this.createBufferStrategy(3);. The '3' argument stands for \"triple buffering\", which is a specific kind of buffering strategy.\r\nGraphics g = bs.getDrawGraphics(); - This retrieves a Graphics object that can be used for drawing to the screen. Any drawing done using this Graphics object is done to one of the buffers in the BufferStrategy.\r\ng.setColor(new Color(136,202,252)); - This sets the current draw color to a light blue color (you configure the RBG values to get different colors).\r\ng.fillRect(0, 0, getWidth(), getHeight()); - This fills the entire screen with the current draw color, effectively 'clearing' the screen before new graphics are drawn.\r\nhandler.render(g); - This line assumes there's a handler object in your program that manages what gets displayed on screen. It's responsible for rendering (or drawing) individual components to the screen.\r\ng.dispose(); - This disposes the graphics context and releases any system resources that it is using.\r\nbs.show(); - This makes the next available buffer visible. It's also part of triple-buffering.\r\nSo in essence, this function prepares the screen, 'clears' the display, delegates the rendering of components to the handler object, and then disposes of the Graphics context and makes the buffer visible.\r\n */
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/GameGUI/Game.java b/src/GameGUI/Game.java
--- a/src/GameGUI/Game.java	(revision a78b5a8b21cbaa5097badad4ecf0ccefc14f938f)
+++ b/src/GameGUI/Game.java	(date 1710524695168)
@@ -24,7 +24,7 @@
     public static int frames = 0;
     public static int updates = 0;
 
-    public Game() throws IOException {
+    public Game() {
 
         new Window(1000, 700, "Pong", this);
         start();
